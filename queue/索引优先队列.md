# 索引优先队列

​        索引优先队列一般基于二叉堆实现，索引优先队列中实际进行排序的元素都有一个固定的索引（一般是一个数组下标），之所以称为索引优先队列，是因为在对二叉堆进行操作过程中操作的不是实际的元素，而是元素的索引。例如对下列元素构建索引优先队列：

 ![元素与索引](F:\Code\basic_algorithm\queue\索引优先队列.jpg)

​        构建优先队列时，队列中的元素是索引，并不对实际的元素进行移动。假设按照索引从0到4的顺序构建堆，最终的二叉堆如下：

 ![二叉堆](二叉堆.jpg)

相对于普通的优先队列，索引优先队列有以下优点：

1. 由于实际操作交换的是索引，所以对于元素比较大的情况下节省了移动元素的消耗；
2. 普通的优先队列只能从队列头一个一个取元素，一个元素一旦入队列之后是无法更改其值的，对于如Dijkstra最短路算法中需要不断改变队列中最短路径的值的情况是不适应的，而索引优先队列可以做到入队后的元素还可以改变值；

主要接口：

```c
/* 插入(k为索引，value为元素) */
void insert(int k, T value);

/* 改变索引为k的元素的值 */
void change(int k, T value);

/* 返回最小的元素 */
T min();

/* 从队列中删除最小的元素（即出队操作），返回该元素的索引 */
int delMin();

/* 检查队列中是否包含索引为k的元素 */
bool contains(int k);
```

其他：

​        以上接口参考《算法》第4版中的内容，书中算法实现使用了pq、qp和keys三个数组，其中keys存放真正的元素，pq中存放元素的索引，对堆得一系列操作也是调整的pq中存放的索引，所以pq的0号元素是不使用的，qp存放的是索引在优先队列中的位置，即pq数组中的位置。如上图中的例子：

​       pq建立的是队列到元素的映射，通过pq中的值可以找到对应的元素；

​        qp建立的是元素到队列的映射，qp的下标即为元素的索引，qp中存放的值为该索引在优先队列中的位置，比如索引为4的元素，在优先队列中的位置是1，那么qp[4] = 1，该数组的主要作用就是在元素值发生变化是可以找到索引在队列中对应的位置，从而进行调整；





