# 最短路算法

## 单源最短路算法

求解单个节点到其他节点的最短路径

### Dijkstra算法

​	Dijkstra算法的核心思想在于按照节点到起点的距离从小到大的顺序进行迭代，假设起点是S，第一次选取距S最近的顶点，第二次选出距S次近的节点，依次类推，知道所有节点都被选完，整个图中每个顶点到起点S的最短路径就都得出了。

​	对于起点S，假设距离起点最近的顶点是u，对于边权重为正数的图，距离S第二近的节点x必然是s->x(假设存在)或者s->u->x两条路径中的一条，以此类推，假设已经求出距离S最近的k个顶点，那么距S最近的第k+1个顶点必然要经过k个顶点或S，这样只需要在这些路径中选择最短一条即为k+1个顶点的最短路径。这也就是说更长的路径必然是由更短路径派生的，从而也说明该算法无法处理**负权重边**的问题。

### 无环加权有向图最短路径

​	**无环**加权有向图可以先对图求拓扑顺序，然后按照拓扑顺序求到每个顶点的最短路径，该算法支持负权重边。之所以支持负权重，是因为拓扑排序的性质所决定的。

​	假设有拓扑顺序如下：

​	5->1->3->6->4->7->0->2

​	顺序在后的节点是不存在路径达到顺序在前的节点的，比如求3到各点的最短路径，其中不存在到5和1的路径，到6的最短路径只能有3发出，到7的最短路径只能选择经过6或4或直接3->7，这对于**负权重边同样适用**。

​	而对于Dijkstra算法，算法顺序是人为依据的距离由小到大顺序，同样求3->7的距离，如果存在负权重的边，就有可能先3->0是一个正的大权重，而后0->7是一个负的大权重，最后总得长度还要短，总体来说就是Dijkstra算法的顺序并不能保证按照这个顺序的路径的唯一性。

### BellmanFord算法

BellmanFord算法可以可以处理负权重边且允许存在环的最短路问题（PS:不允许存在负权重环，负权重环的图不存在最短路径）；

在Dijkstra算法中，条件是所有边都是正权重，处理顺序是先处理离顶点最近的顶点，顶点只要从优先队列中出队后，就代表该顶点已经找到了最短路径，不会再次入队了，对于存在负权重边的图，有可能存在这样的路径，该路径最开始断距离起点权重很大，但是后面存在负权重边，总得路径权重反而更小，由于算法不会重新将出队的节点入队，也就无法处理此种情况。

BellmanFord算法可以解决这种情况，原因在于只要该节点的最短路径进行了更新，就可以重新入队；Bellmanford算法对节点进行处理时没有特定的顺序，这样也造成了算法的时间复杂度较高的情况，因为要对所有的边E处理V(节点数)轮，其队列优化版本避免了对所有边都进行处理的操作，只处理距离发生变化的边。

BellmanFord算法可以在V轮处理之后得到最短路径，如果在V轮处理之后队列仍然非空，则代表存在负权重环，该图不存在最短路径。

### 比较

|     算法      | 适用范围  | 时间复杂度 | 空间复杂度 |
| :---------: | :---: | :---: | :---: |
|  Dijkstra   | 边权重为正 | ElogV |   V   |
|    拓扑排序     |  无环   |  E+V  |   V   |
| BellmanFord | 无负权重环 |  EV   |   V   |

